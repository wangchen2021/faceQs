# 任务调度

`合作式任务调度`和`抢占式任务调度`是操作系统中进程/线程调度的两种核心模式，核心区别在于**任务切换的触发权归属**，直接影响系统的响应性、公平性和资源利用率。

### 一、核心定义与核心区别
| 特性                | 合作式任务调度（Cooperative Scheduling）| 抢占式任务调度（Preemptive Scheduling）|
|---------------------|-----------------------------------------------------------------------------|-----------------------------------------------------------------------------|
| 切换触发权          | 由**当前运行任务主动放弃CPU**（如执行完任务、调用阻塞API、主动yield）| 由**操作系统内核强制剥夺CPU**（基于时间片、优先级等规则）|
| 调度时机            | 任务主动释放CPU时                                                           | 时间片耗尽、更高优先级任务就绪、当前任务阻塞时                             |
| 核心依赖            | 任务的“自觉性”（必须主动让出CPU）| 内核的强制干预（定时器中断、优先级判断）|
| 响应性              | 低（高优先级任务可能长期等待低优先级任务释放CPU）| 高（高优先级任务可立即抢占CPU，响应延迟可控）|
| 实现复杂度          | 简单（无需内核强制切换机制，依赖任务协作）| 复杂（需处理上下文切换、资源竞争、中断安全）|
| 公平性              | 差（恶意/卡死任务会独占CPU）| 好（每个任务按规则分配CPU时间）|

### 二、合作式任务调度（协作式调度）
#### 1. 工作原理
任务一旦获得CPU，会持续运行直到**主动放弃CPU控制权**——比如：
- 任务执行完毕，正常退出；
- 调用阻塞型系统调用（如读写文件、网络请求、sleep）；
- 主动调用`yield()`等接口，自愿交出CPU；
- 发生异常（如崩溃）。

操作系统仅在任务主动释放CPU时，才会调度下一个就绪任务。

#### 2. 典型场景与例子
- **早期操作系统**：如Windows 3.x、Mac OS 9（均为合作式调度）；
- **嵌入式系统/简单运行时**：如一些单片机的任务调度、Python的GIL（全局解释器锁）在单线程下的调度（线程需主动释放GIL）；
- **JavaScript事件循环**：浏览器/Node.js的事件循环本质是合作式调度——任务（宏任务/微任务）一旦开始执行，会运行到完成，不会被打断，直到主动进入下一轮事件循环。

#### 3. 优点与缺点
- **优点**：
  - 实现简单：无需内核复杂的抢占机制，上下文切换开销小；
  - 无“抢占中断”：任务运行过程中不会被强制打断，避免资源竞争的部分问题（如无需额外的锁保护简单资源）。
- **缺点**：
  - 响应性差：若低优先级任务卡死或不主动释放CPU，高优先级任务会永远等待（“饿死”）；
  - 可靠性低：单个任务的异常可能导致整个系统卡死；
  - 公平性差：恶意任务可独占CPU资源。

### 三、抢占式任务调度
#### 1. 工作原理
操作系统通过**定时器中断**（如每10ms触发一次）或**事件触发**（如高优先级任务就绪），强制剥夺当前任务的CPU控制权，保存其上下文（寄存器、程序计数器等），然后调度下一个符合规则的任务（如更高优先级、时间片未用完的任务）。

核心规则：
- **时间片轮转**：每个任务分配固定时间片（如10ms），时间片耗尽则被抢占；
- **优先级抢占**：当更高优先级任务进入就绪态，立即抢占当前低优先级任务的CPU；
- **公平调度**：按比例分配CPU时间，避免单个任务独占。

#### 2. 典型场景与例子
- **现代操作系统**：Windows NT及以上、Linux、macOS（均为抢占式调度）；
- **实时操作系统（RTOS）**：如FreeRTOS、VxWorks（强调查询优先级抢占，保证实时响应）；
- **多核CPU调度**：内核在多个核心间抢占式分配任务，最大化资源利用率。

#### 3. 优点与缺点
- **优点**：
  - 响应性高：高优先级任务可立即得到CPU，适合实时场景（如工业控制、游戏渲染）；
  - 可靠性高：单个任务卡死不会独占CPU，内核可强制调度其他任务；
  - 公平性好：每个任务按规则分配CPU时间，避免“饿死”。
- **缺点**：
  - 实现复杂：需处理上下文切换、中断同步、资源竞争（如临界区需加锁）；
  - 开销较大：频繁的抢占和上下文切换会消耗CPU资源；
  - 可能出现“优先级反转”：低优先级任务持有高优先级任务需要的资源，导致高优先级任务等待（需通过优先级继承等机制解决）。

### 四、关键对比案例
#### 案例1：JavaScript事件循环（合作式）
假设浏览器中有两个任务：
- 任务A：执行一个耗时10秒的循环（无阻塞、无yield）；
- 任务B：点击按钮的回调（高优先级交互任务）。

在合作式调度下，任务A会持续运行10秒，期间点击按钮的任务B无法执行，页面完全卡死，直到任务A结束。

#### 案例2：Linux进程调度（抢占式）
假设Linux中有两个进程：
- 进程X：低优先级的后台计算任务（时间片10ms）；
- 进程Y：高优先级的键盘输入响应任务。

当用户按下键盘，进程Y进入就绪态，Linux内核会立即抢占进程X的CPU（即使X的时间片未用完），优先执行进程Y，保证键盘输入实时响应；进程X会在Y执行完后继续运行。

### 五、总结
- **合作式调度**：“自愿让贤”，简单但依赖任务协作，适合简单系统或无实时要求的场景（如前端事件循环）；
- **抢占式调度**：“强制分配”，复杂但响应性、可靠性高，是现代操作系统和实时系统的主流选择。

两者的选择本质是**实现复杂度**与**系统性能/可靠性**的权衡——合作式牺牲响应性换简单实现，抢占式牺牲实现复杂度换更好的用户体验和系统稳定性。



- 合作式任务调度`scheduler`
确定任务执行的优先级

- 抢占式任务调度``

- 避免任务饿死
1. react 的时间切片
2. aging 对于过期任务即将饿死任务提高其优先级

## `React Scheduler（调度器）`

是**以合作式任务调度为核心，同时融入了抢占式调度的“伪抢占”特性**的混合调度模式，并非纯合作式或纯抢占式调度，其设计目标是兼顾任务执行的稳定性与高优先级任务的响应性。

### 一、核心：基于合作式调度的“自愿让出”
React Scheduler 的底层核心遵循合作式调度的核心逻辑——**任务不会被强制打断，必须由当前任务主动让出 CPU 控制权**。

具体表现为：
1.  React Scheduler 将渲染任务（如 Fiber 树的遍历、调和）拆分为多个“小粒度任务单元”（而非一次性执行完整渲染流程）；
2.  每个小任务单元执行完毕后，调度器会主动检查是否存在更高优先级任务、是否超出浏览器帧时间（通常 16.6ms，对应 60fps）；
3.  若满足“需要暂停”的条件，当前任务会主动调用 `yield` 放弃执行权，将控制权交还给浏览器（执行渲染、用户交互等），待下一次事件循环再继续执行剩余任务；
4.  若当前任务未执行完且无需暂停，则会继续执行下一个小任务单元，直到任务完成或满足暂停条件。

这种“主动放弃、分段执行”的逻辑，完全符合合作式调度“任务自主让出 CPU”的核心特征，避免了任务执行过程中被强制打断导致的状态混乱。

### 二、扩展：模拟“伪抢占”的时间切片（Time Slicing）
为了解决纯合作式调度响应性不足的问题（低优先级长任务阻塞高优先级任务），React Scheduler 引入了**时间切片（Time Slicing）**技术，实现了“伪抢占”效果（并非操作系统级别的真正抢占）。

具体实现逻辑：
1.  **时间阈值检测**：Scheduler 会通过 `requestIdleCallback`（降级方案为 `setTimeout`）检测浏览器的空闲时间，或直接以 5ms 左右作为单个任务切片的时间阈值；
2.  **任务执行监控**：在当前任务执行过程中，Scheduler 会周期性检查已执行时间是否超出阈值，或是否有更高优先级任务（如用户点击、输入等交互任务）进入任务队列；
3.  **主动暂停与任务插队**：当检测到时间耗尽或高优先级任务就绪时，当前执行的低优先级任务会主动暂停（保存当前 Fiber 节点状态），并将高优先级任务插入任务队列头部；
4.  **后续恢复执行**：高优先级任务执行完毕后，Scheduler 会从之前暂停的 Fiber 节点继续执行低优先级任务，无需重新开始。

需要注意的是：这种“抢占”并非操作系统内核强制剥夺 CPU，而是**在任务内部通过时间检测实现的主动暂停与任务优先级插队**，本质是“模拟抢占”，而非真正的抢占式调度。

### 三、与纯合作式/纯抢占式调度的区别
| 特性                | React Scheduler                | 纯合作式调度                  | 纯抢占式调度                  |
|---------------------|--------------------------------|-------------------------------|-------------------------------|
| 任务切换触发方式    | 主动暂停（合作式核心）+ 优先级插队（伪抢占） | 任务完全自愿让出              | 操作系统内核强制剥夺          |
| 抢占本质            | 逻辑层模拟（用户态）| 无抢占                        | 内核层强制（内核态）|
| 高优先级任务响应    | 快速（伪抢占插队，延迟可控）| 缓慢（需等待当前任务主动让出） | 实时（立即强制抢占）|
| 任务执行稳定性      | 高（无强制打断，状态易维护）| 高（无强制打断）| 较低（强制打断需处理上下文保护） |
| 实现依赖            | 任务粒度拆分 + 时间检测        | 任务自觉性                    | 操作系统定时器中断 + 优先级机制 |

### 四、设计初衷：兼顾渲染性能与用户交互响应
React Scheduler 采用这种混合调度模式，核心是为了解决传统 React 同步渲染的问题：
1.  纯同步渲染（无调度）：长渲染任务会阻塞浏览器主线程，导致用户交互（点击、输入）卡顿，页面失去响应；
2.  纯合作式调度：若渲染任务未拆分，仍会阻塞高优先级交互任务；
3.  纯抢占式调度：操作系统级抢占会增加渲染状态维护的复杂度，且浏览器主线程不支持真正的抢占式调度。

通过“合作式分段执行 + 伪抢占优先级插队”，React Scheduler 既保证了渲染任务的稳定执行（无强制打断），又能让高优先级交互任务优先执行，实现“流畅渲染”与“实时交互”的兼顾。

### 总结
1.  React Scheduler 不是纯合作式或纯抢占式调度，而是**以合作式调度为核心，通过时间切片实现伪抢占的混合调度模式**；
2.  核心逻辑是“任务主动让出 CPU”（合作式），伪抢占通过“时间检测 + 优先级插队”实现，非操作系统级强制抢占；
3.  设计目标是解决主线程阻塞问题，兼顾渲染性能与用户交互响应性，这也是 React 16+ 支持 Fiber 架构的核心基础。